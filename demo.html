<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="shortcut icon" href="#" type="image/x-icon" />
    <title>Streaming Plugin Demo</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        background: linear-gradient(135deg, #dbeafe 0%, #bfdbfe 100%);
        min-height: 100vh;
        overflow-x: hidden;
        color: #1f2937;
      }

      .task-manager {
        background: rgba(255, 255, 255, 0.95);
        backdrop-filter: blur(10px);
        border-radius: 8px;
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        margin: 20px;
        overflow: hidden;
      }

      .header {
        background: #2d3748;
        color: white;
        padding: 15px 20px;
        display: flex;
        align-items: center;
        justify-content: space-between;
        border-bottom: 2px solid #4a5568;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      }

      .header h1 {
        font-size: 18px;
        font-weight: 400;
        display: flex;
        align-items: center;
        gap: 10px;
      }

      .header-icon {
        width: 24px;
        height: 24px;
        background: #6b7280;
        border-radius: 3px;
        display: flex;
        align-items: center;
        justify-content: center;
        font-weight: bold;
        color: white;
        padding: 15px 20px;
      }

      .system-info {
        display: flex;
        gap: 20px;
        align-items: center;
        font-size: 12px;
      }

      .info-item {
        display: flex;
        align-items: center;
        gap: 5px;
      }

      .content {
        padding: 20px;
        background: white;
      }

      .metrics-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
        gap: 20px;
        margin-bottom: 30px;
      }

      .metric-card {
        background: white;
        border: 1px solid #e2e8f0;
        border-radius: 12px;
        padding: 15px;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.05);
      }

      .metric-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 10px;
      }

      .metric-title {
        font-size: 14px;
        font-weight: 600;
        color: #323130;
      }

      .metric-value {
        font-size: 24px;
        font-weight: 300;
        color: #0078d4;
      }

      .metric-unit {
        font-size: 12px;
        color: #666;
        margin-left: 4px;
      }

      .chart-container {
        height: 200px;
        margin-top: 10px;
      }

      .processes-section {
        margin-top: 30px;
      }

      .section-title {
        font-size: 16px;
        font-weight: 600;
        margin-bottom: 15px;
        color: #323130;
      }

      .processes-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
        gap: 15px;
      }

      .process-card {
        background: #ffffff;
        border: 1px solid #e2e8f0;
        border-radius: 8px;
        padding: 12px;
        display: flex;
        align-items: center;
        gap: 10px;
      }

      .process-icon {
        width: 32px;
        height: 32px;
        border-radius: 6px;
        display: flex;
        align-items: center;
        justify-content: center;
        color: white;
        font-weight: bold;
        font-size: 12px;
      }

      .process-info {
        flex: 1;
      }

      .process-name {
        font-size: 13px;
        font-weight: 500;
        color: #323130;
      }

      .process-cpu {
        font-size: 11px;
        color: #666;
      }

      .status-bar {
        background: #f3f3f3;
        border-top: 1px solid #d1d1d1;
        padding: 10px 20px 15px;
        display: flex;
        justify-content: space-between;
        align-items: center;
        font-size: 12px;
        color: #666;
      }

      .status-item {
        display: flex;
        align-items: center;
        gap: 5px;
      }

      .status-indicator {
        width: 8px;
        height: 8px;
        border-radius: 50%;
        background: #107c10;
      }

      @media (max-width: 768px) {
        .metrics-grid {
          grid-template-columns: 1fr;
        }

        .processes-grid {
          grid-template-columns: 1fr;
        }

        .system-info {
          display: none;
        }
      }
    </style>
  </head>
  <body>
    <div class="task-manager">
      <div class="header">
        <h1>
          <div class="header-icon">TM</div>
          Task Manager
        </h1>
        <div class="system-info">
          <div class="info-item">
            <span>üñ•Ô∏è</span>
            <span id="systemName">System Monitor</span>
          </div>
          <div class="info-item">
            <span>‚è±Ô∏è</span>
            <span id="uptime">Uptime: 0:00:00</span>
          </div>
          <div class="info-item">
            <span>üîã</span>
            <span id="battery">100%</span>
          </div>
        </div>
      </div>

      <div class="content">
        <div class="metrics-grid">
          <div class="metric-card">
            <div class="metric-header">
              <div class="metric-title">CPU Usage</div>
              <div class="metric-value">
                <span id="cpu-value">0</span>
                <span class="metric-unit">%</span>
              </div>
            </div>
            <div class="chart-container">
              <canvas id="cpu-chart"></canvas>
            </div>
          </div>

          <div class="metric-card">
            <div class="metric-header">
              <div class="metric-title">Memory Usage</div>
              <div class="metric-value">
                <span id="memory-value">0</span>
                <span class="metric-unit">%</span>
              </div>
            </div>
            <div class="chart-container">
              <canvas id="memory-chart"></canvas>
            </div>
          </div>

          <div class="metric-card">
            <div class="metric-header">
              <div class="metric-title">Disk Usage</div>
              <div class="metric-value">
                <span id="disk-value">0</span>
                <span class="metric-unit">%</span>
              </div>
            </div>
            <div class="chart-container">
              <canvas id="disk-chart"></canvas>
            </div>
          </div>

          <div class="metric-card">
            <div class="metric-header">
              <div class="metric-title">Network Usage</div>
              <div class="metric-value">
                <span id="network-value">0</span>
                <span class="metric-unit">Mbps</span>
              </div>
            </div>
            <div class="chart-container">
              <canvas id="network-chart"></canvas>
            </div>
          </div>

          <div class="metric-card">
            <div class="metric-header">
              <div class="metric-title">GPU Usage</div>
              <div class="metric-value">
                <span id="gpu-value">0</span>
                <span class="metric-unit">%</span>
              </div>
            </div>
            <div class="chart-container">
              <canvas id="gpu-chart"></canvas>
            </div>
          </div>

          <div class="metric-card">
            <div class="metric-header">
              <div class="metric-title">Temperature</div>
              <div class="metric-value">
                <span id="temp-value">0</span>
                <span class="metric-unit">¬∞C</span>
              </div>
            </div>
            <div class="chart-container">
              <canvas id="temp-chart"></canvas>
            </div>
          </div>
        </div>

        <div class="processes-section">
          <div class="section-title">Running Processes</div>
          <div class="processes-grid" id="processes-grid">
            <!-- Processes will be added dynamically -->
          </div>
        </div>
      </div>

      <div class="status-bar">
        <div class="status-item">
          <div class="status-indicator"></div>
          <span>System Running</span>
        </div>
        <div class="status-item">
          <span id="process-count">0</span> processes
        </div>
        <div class="status-item">
          <span id="update-time">Last updated: Just now</span>
        </div>
      </div>
    </div>

    <!-- Use local development packages -->
    <script src="./node_modules/chart.js/dist/chart.umd.js"></script>
    <script src="./node_modules/luxon/build/global/luxon.min.js"></script>
    <script src="./node_modules/chartjs-adapter-luxon/dist/chartjs-adapter-luxon.umd.min.js"></script>
    <script src="./dist/chartjs-plugin-streaming.js"></script>

    <script>
      // Global variables
      let charts = {};
      let startTime = Date.now();
      let processes = [];

      // Generate realistic metric values
      function generateMetricValue(metric) {
        const baseValues = {
          cpu: 30,
          memory: 45,
          disk: 15,
          network: 50,
          gpu: 25,
          temp: 45
        };

        const variation = {
          cpu: 40,
          memory: 30,
          disk: 25,
          network: 50,
          gpu: 60,
          temp: 25
        };

        const base = baseValues[metric] || 50;
        const varRange = variation[metric] || 30;

        // Add some realistic patterns
        const time = Date.now() / 1000;
        const wave = Math.sin(time / 10) * (varRange * 0.3);
        const noise = (Math.random() - 0.5) * (varRange * 0.4);

        return Math.max(0, Math.min(100, base + wave + noise));
      }

      // Update metric display
      function updateMetricDisplay(metric, value) {
        const element = document.getElementById(`${metric}-value`);
        if (element) {
          if (metric === 'network') {
            element.textContent = Math.round(value);
          } else if (metric === 'temp') {
            element.textContent = Math.round(value);
          } else {
            element.textContent = Math.round(value);
          }

          // Apply color based on metric type
          const colorMap = {
            cpu: '#3b82f6',
            memory: '#10b981',
            disk: '#F7B93E',
            network: '#8b5cf6',
            gpu: '#f97316',
            temp: '#dc2626'
          };

          element.style.color = colorMap[metric] || '#000';
        }
      }

      // Initialize charts
      function initializeCharts() {
        const baseChartOptions = {
          responsive: true,
          maintainAspectRatio: false,
          interaction: {
            intersect: false,
            mode: 'index'
          },
          plugins: {
            legend: {
              display: false
            },
            tooltip: {
              enabled: true,
              backgroundColor: 'rgba(0, 0, 0, 0.8)',
              titleColor: '#fff',
              bodyColor: '#fff',
              borderColor: '#0078d4',
              borderWidth: 1
            }
          },
          scales: {
            x: {
              type: 'realtime',
              realtime: {
                duration: 30000,
                refresh: 1000,
                delay: 1000,
                onRefresh: function (chart) {
                  const now = Date.now();
                  const metricName = chart.canvas.id.replace('-chart', '');
                  const value = generateMetricValue(metricName);

                  chart.data.datasets[0].data.push({
                    x: now,
                    y: value
                  });

                  // Update display value
                  updateMetricDisplay(metricName, value);
                }
              }
            },
            y: {
              beginAtZero: true,
              max: 100,
              grid: {
                color: 'rgba(0, 0, 0, 0.05)'
              },
              ticks: {
                color: '#666',
                font: {
                  size: 10
                }
              }
            }
          },
          elements: {
            line: {
              borderWidth: 2,
              tension: 0.4,
              fill: true
            },
            point: {
              radius: 0,
              hoverRadius: 4
            }
          }
        };

        // CPU Chart
        try {
          charts.cpu = new Chart(document.getElementById('cpu-chart'), {
            type: 'line',
            data: {
              datasets: [
                {
                  data: [],
                  borderColor: '#3b82f6',
                  backgroundColor: 'rgba(59, 130, 246, 0.1)',
                  fill: true
                }
              ]
            },
            options: baseChartOptions
          });
        } catch (error) {}

        // Memory Chart
        try {
          charts.memory = new Chart(document.getElementById('memory-chart'), {
            type: 'line',
            data: {
              datasets: [
                {
                  data: [],
                  borderColor: '#10b981',
                  backgroundColor: 'rgba(16, 185, 129, 0.1)',
                  fill: true
                }
              ]
            },
            options: baseChartOptions
          });
        } catch (error) {}

        // Disk Chart
        try {
          charts.disk = new Chart(document.getElementById('disk-chart'), {
            type: 'line',
            data: {
              datasets: [
                {
                  data: [],
                  borderColor: '#F7B93E',
                  backgroundColor: 'rgba(247, 185, 62, 0.1)',
                  fill: true
                }
              ]
            },
            options: baseChartOptions
          });
        } catch (error) {}

        // Network Chart
        try {
          charts.network = new Chart(document.getElementById('network-chart'), {
            type: 'line',
            data: {
              datasets: [
                {
                  data: [],
                  borderColor: '#8b5cf6',
                  backgroundColor: 'rgba(139, 92, 246, 0.1)',
                  fill: true
                }
              ]
            },
            options: {
              ...baseChartOptions,
              scales: {
                ...baseChartOptions.scales,
                y: {
                  ...baseChartOptions.scales.y,
                  max: 100
                }
              }
            }
          });
        } catch (error) {}

        // GPU Chart
        try {
          charts.gpu = new Chart(document.getElementById('gpu-chart'), {
            type: 'line',
            data: {
              datasets: [
                {
                  data: [],
                  borderColor: '#f97316',
                  backgroundColor: 'rgba(249, 115, 22, 0.1)',
                  fill: true
                }
              ]
            },
            options: baseChartOptions
          });
        } catch (error) {}

        // Temperature Chart
        try {
          charts.temp = new Chart(document.getElementById('temp-chart'), {
            type: 'line',
            data: {
              datasets: [
                {
                  data: [],
                  borderColor: '#dc2626',
                  backgroundColor: 'rgba(220, 38, 38, 0.1)',
                  fill: true
                }
              ]
            },
            options: {
              ...baseChartOptions,
              scales: {
                ...baseChartOptions.scales,
                y: {
                  ...baseChartOptions.scales.y,
                  max: 100
                }
              }
            }
          });
        } catch (error) {}
      }

      // Generate processes
      function generateProcesses() {
        const processNames = [
          'node',
          'npm',
          'yarn',
          'vite',
          'webpack',
          'babel',
          'typescript',
          'eslint',
          'prettier',
          'jest',
          'cypress',
          'playwright',
          'redis-server',
          'postgres',
          'mysql',
          'mongodb',
          'docker',
          'docker-compose',
          'nginx',
          'apache',
          'vscode',
          'code-server',
          'chrome',
          'firefox',
          'safari',
          'selenium',
          'puppeteer',
          'webpack-dev-server',
          'vite-server',
          'nextjs',
          'nuxtjs',
          'gatsby',
          'create-react-app',
          'angular-cli',
          'vue-cli',
          'storybook',
          'jest-worker',
          'tsc',
          'nodemon',
          'pm2',
          'supervisor',
          'forever',
          'express',
          'fastify',
          'nestjs',
          'prisma',
          'sequelize',
          'knex',
          'typeorm'
        ];

        const numProcesses = 8;
        const newProcesses = [];

        // Create a shuffled copy of process names to ensure uniqueness
        const shuffledNames = [...processNames].sort(() => 0.5 - Math.random());
        const selectedNames = shuffledNames.slice(0, numProcesses);

        for (let i = 0; i < numProcesses; i++) {
          const name = selectedNames[i];
          const cpu = Math.round(Math.random() * 80);
          const memory = Math.round(Math.random() * 2000);

          newProcesses.push({
            name: name,
            cpu: cpu,
            memory: memory,
            icon: name.substring(0, 2).toUpperCase()
          });
        }

        // Sort by CPU usage
        newProcesses.sort((a, b) => b.cpu - a.cpu);
        processes = newProcesses;
      }

      // Update processes display
      function updateProcessesDisplay() {
        const grid = document.getElementById('processes-grid');

        if (grid) {
          grid.innerHTML = processes
            .slice(0, 8)
            .map(
              (process) => `
                    <div class="process-card">
                        <div class="process-icon" style="background:${getProcessColor(
                          process.name
                        )}">${process.icon}</div>
                        <div class="process-info">
                            <div class="process-name">${process.name}</div>
                            <div class="process-cpu">CPU: ${
                              process.cpu
                            }% | Memory: ${process.memory}MB</div>
                        </div>
                    </div>
                `
            )
            .join('');
        }

        // Update process count
        document.getElementById('process-count').textContent = processes.length;
      }

      // Update uptime
      function updateUptime() {
        const elapsed = Date.now() - startTime;
        const hours = Math.floor(elapsed / 3600000);
        const minutes = Math.floor((elapsed % 3600000) / 60000);
        const seconds = Math.floor((elapsed % 60000) / 1000);

        document.getElementById(
          'uptime'
        ).textContent = `Uptime: ${hours}:${minutes
          .toString()
          .padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
      }

      // Update last update time
      function updateLastUpdateTime() {
        const now = new Date();
        const timeString = now.toLocaleTimeString();
        document.getElementById(
          'update-time'
        ).textContent = `Last updated: ${timeString}`;
      }

      // Get color based on process type
      function getProcessColor(processName) {
        const colorMap = {
          // Server/Backend processes
          nginx: '#269ABC',
          apache: '#D9534F',
          node: '#8CC84B',
          express: '#8CC84B',
          fastify: '#1A56DB',
          nestjs: '#E0234E',
          mysql: '#DC382D',
          postgres: '#336791',
          mongodb: '#4FAA4D',
          redis: '#DC382D',

          // Build tools & Dev tools
          webpack: '#1C78C0',
          vite: '#4F46E5',
          babel: '#D97706',
          typescript: '#3178C6',
          eslint: '#4B32C3',
          prettier: '#7C3AED',
          jest: '#C21325',

          // Package managers
          npm: '#CB3837',
          yarn: '#2C8EBB',

          // Editors/IDEs
          vscode: '#007ACC',
          'code-server': '#007ACC',

          // Databases
          docker: '#2496ED',
          'docker-compose': '#2496ED',
          prisma: '#2D3748',
          sequelize: '#4DAD5F',
          knex: '#C35831',
          typeorm: '#C34A2C',

          // Testing
          cypress: '#4B5563',
          selenium: '#6B61B4',
          playwright: '#16A34A',
          puppeteer: '#0D9488',

          // Frameworks
          nextjs: '#003D82',
          nuxtjs: '#007C4F',
          gatsby: '#663399',
          'create-react-app': '#2E6D99',
          'angular-cli': '#DD0031',
          'vue-cli': '#2D6B58',
          storybook: '#B91C1C'
        };

        return colorMap[processName] || getRandomColor(processName);
      }

      // Fallback to generate consistent colors for unknown processes
      function getRandomColor(processName) {
        // Create a deterministic color based on process name
        let hash = 0;
        for (let i = 0; i < processName.length; i++) {
          hash = processName.charCodeAt(i) + ((hash << 5) - hash);
        }

        // Convert to HSL for more pleasant colors
        const hue = hash % 360;
        return `hsl(${hue}, 70%, 50%)`;
      }

      // Initialize everything
      function init() {
        try {
          initializeCharts();

          generateProcesses();
          updateProcessesDisplay();

          // Update processes every 5 seconds
          setInterval(() => {
            generateProcesses();
            updateProcessesDisplay();
          }, 5000);

          // Update uptime every second
          setInterval(updateUptime, 1000);

          // Update last update time every second
          setInterval(updateLastUpdateTime, 1000);

          // Initial updates
          updateUptime();
          updateLastUpdateTime();
        } catch (error) {}
      }

      // Start when DOM is ready
      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', init);
      } else {
        init();
      }
    </script>
  </body>
</html>
